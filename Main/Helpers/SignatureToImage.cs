/*
 * This class is based on the following project but was modified to support dynamic sizes and byte arrays so take care if you want to update it
 * Author:		Curtis Herbert (me@forgottenexpanse.com)
 * License:		BSD License 
 * Version:		1.0 (2011-03-31)
 * URL:				https://github.com/parrots/SignatureToImageDotNet
 */

namespace Crm.Helpers
{
	using System;
	using System.Collections.Generic;
	using System.Drawing;
	using System.Drawing.Drawing2D;
	using System.Drawing.Imaging;
	using System.IO;
	using System.Linq;

	using Newtonsoft.Json;

	/// <summary>
	/// A server-side supplement to Signature Pad (http://thomasjbradley.ca/lab/signature-to-image) used to create an image 
	/// of the user's signature based on either the name they entered or the hand-drawn signature they provided.
	/// </summary>
	public static class SignatureToImage
	{
		public static Color PenColor { get; set; }
		public static Color Background { get; set; }
		public static int PenWidth { get; set; }
		public static int FontSize { get; set; }

		/// <summary>
		/// Gets a new signature gernator with the default options.
		/// </summary>
		static SignatureToImage()
		{
			PenColor = Color.Black;
			Background = Color.White;
			// we set the Height & Width dynamically later
			// Height = 55;
			// Width = 248;
			PenWidth = 2;
			FontSize = 24;
		}

		public static int GetSignatureWidth(string json)
		{
			var lines = JsonConvert.DeserializeObject<List<SignatureLine>>(json ?? string.Empty);
			var maxX = Math.Max(lines.Max(l => l.lx), lines.Max(l => l.mx));
			return (int)(1.02 * maxX);
		}

		public static int GetSignatureHeight(string json)
		{
			var lines = JsonConvert.DeserializeObject<List<SignatureLine>>(json ?? string.Empty);
			var maxY = Math.Max(lines.Max(l => l.ly), lines.Max(l => l.my));
			return (int)(1.02 * maxY);
		}

		/// <summary>
		/// Draws a signature based on the JSON provided by Signature Pad.
		/// </summary>
		/// <param name="json">JSON string of line drawing commands.</param>
		/// <returns>Bitmap image containing the user's signature.</returns>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]
		public static Bitmap SigJsonToImage(string json)
		{
			var signatureImage = new Bitmap(GetSignatureWidth(json), GetSignatureHeight(json));
			signatureImage.MakeTransparent();
			using (var signatureGraphic = Graphics.FromImage(signatureImage))
			{
				signatureGraphic.Clear(Background);
				signatureGraphic.SmoothingMode = SmoothingMode.AntiAlias;
				var pen = new Pen(PenColor, PenWidth);
				var lines = JsonConvert.DeserializeObject<List<SignatureLine>>(json ?? string.Empty);
				foreach (SignatureLine line in lines)
				{
					signatureGraphic.DrawLine(pen, line.lx, line.ly, line.mx, line.my);
				}
			}
			return signatureImage;
		}

		[System.Diagnostics.CodeAnalysis.SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]
		public static byte[] SigJsonToByteArray(string json)
		{
			var memoryStream = new MemoryStream();
			var signatureBitmap = SigJsonToImage(json);
			signatureBitmap.Save(memoryStream, ImageFormat.Png);
			return memoryStream.ToArray();
		}

		/// <summary>
		/// Line drawing commands as generated by the Signature Pad JSON export option.
		/// </summary>
		private class SignatureLine
		{
			public int lx { get; set; }
			public int ly { get; set; }
			public int mx { get; set; }
			public int my { get; set; }
		}
	}
}
